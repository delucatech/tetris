<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Tetris on Oculus Quest 3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    
    /* Debug panel */
    #debug-panel {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      max-height: 150px;
      overflow-y: auto;
    }
    
    #debug-log {
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
      margin-bottom: 10px;
    }
    
    #state-info {
      font-size: 12px;
      margin-bottom: 10px;
    }
    
    #debug-controls {
      display: flex;
      gap: 10px;
    }
    
    /* Simple HUD overlay for score and controls */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 1;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
    
    #hud > div { margin-bottom: 5px; }
    button { font-size: 16px; margin: 5px 0; padding: 8px 12px; }
    
    /* Make buttons more touch-friendly for Quest 3 */
    #control-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    
    #control-buttons button {
      min-height: 44px;
    }
    
    /* Extra visibility */
    #start-btn {
      background-color: #4CAF50;
      color: white;
      font-weight: bold;
    }
    
    .debug-button {
      background-color: #ff9800;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Heads-up display overlay -->
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Lines: <span id="lines">0</span></div>
    <button id="start-btn">Start Game</button>
    <button id="pause-btn">Pause</button>
    <button id="restart-btn">Restart</button>
    <div>
      <input type="checkbox" id="ghost-toggle" checked>
      <label for="ghost-toggle">Show Ghost</label>
    </div>
    
    <!-- Touch controls for Quest 3 -->
    <div id="control-buttons">
      <button id="move-left">←</button>
      <button id="rotate">↻</button>
      <button id="move-right">→</button>
      <button id="move-down">↓</button>
      <button id="hard-drop">Drop</button>
    </div>
  </div>
  
  <!-- Debug panel -->
  <div id="debug-panel">
    <div id="state-info">State: Initializing...</div>
    <div id="debug-log">Debug log initialized.</div>
    <div id="debug-controls">
      <button class="debug-button" id="debug-place-board">Force Place Board</button>
      <button class="debug-button" id="toggle-debug">Show/Hide Debug</button>
      <button class="debug-button" id="clear-log">Clear Log</button>
      <button class="debug-button" id="check-xr">Check XR Status</button>
    </div>
  </div>

  <!-- Three.js and AR code -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // Debug utilities
    const debugLog = document.getElementById('debug-log');
    const stateInfo = document.getElementById('state-info');
    const toggleDebugBtn = document.getElementById('toggle-debug');
    const clearLogBtn = document.getElementById('clear-log');
    const checkXRBtn = document.getElementById('check-xr');
    const debugPlaceBoardBtn = document.getElementById('debug-place-board');
    const debugPanel = document.getElementById('debug-panel');
    
    let logMessages = [];
    const MAX_LOG_MESSAGES = 20;
    
    function log(message) {
      console.log(message); // Also log to browser console
      const timestamp = new Date().toLocaleTimeString();
      logMessages.push(`[${timestamp}] ${message}`);
      
      // Keep log size manageable
      if (logMessages.length > MAX_LOG_MESSAGES) {
        logMessages.shift();
      }
      
      debugLog.textContent = logMessages.join('\n');
      debugLog.scrollTop = debugLog.scrollHeight; // Auto-scroll to bottom
    }
    
    function updateStateInfo() {
      let stateText = `XR Available: ${navigator.xr ? 'Yes' : 'No'}\n`;
      stateText += `XR Session Active: ${renderer.xr.isPresenting ? 'Yes' : 'No'}\n`;
      stateText += `Board Placed: ${boardPlaced ? 'Yes' : 'No'}\n`;
      stateText += `Game State: ${isGameOver ? 'Game Over' : isPaused ? 'Paused' : gameInterval ? 'Running' : 'Stopped'}\n`;
      stateText += `Current Piece: ${currentPiece ? 'Yes' : 'No'}\n`;
      
      stateInfo.textContent = stateText;
    }
    
    // Debug panel controls
    toggleDebugBtn.addEventListener('click', () => {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });
    
    clearLogBtn.addEventListener('click', () => {
      logMessages = [];
      debugLog.textContent = 'Log cleared.';
    });
    
    checkXRBtn.addEventListener('click', () => {
      log('Checking XR status...');
      
      if (!navigator.xr) {
        log('ERROR: WebXR API not available in this browser');
        return;
      }
      
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        log(`AR Session Support: ${supported ? 'YES' : 'NO'}`);
      });
      
      // Report additional info
      log(`XR Session Active: ${renderer.xr.isPresenting ? 'Yes' : 'No'}`);
      log(`Hit Test Source: ${hitTestSource ? 'Available' : 'Not Available'}`);
      
      // Check display settings
      log(`Device Pixel Ratio: ${window.devicePixelRatio}`);
      log(`Canvas Size: ${renderer.domElement.width} x ${renderer.domElement.height}`);
      
      updateStateInfo();
    });
    
    debugPlaceBoardBtn.addEventListener('click', () => {
      log('Forcing board placement...');
      if (!boardPlaced) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        log('Board forcibly placed at position (0, 0, -1)');
        updateScene();
      } else {
        log('Board already placed. Current position:');
        log(`x: ${boardGroup.position.x.toFixed(2)}, y: ${boardGroup.position.y.toFixed(2)}, z: ${boardGroup.position.z.toFixed(2)}`);
      }
      updateStateInfo();
    });

    // --- Game configuration and state ---
    const cellSize = 0.05; // world units per Tetris cell
    const COLS = 10, ROWS = 20;
    const boardHeight = ROWS * cellSize; // used for coordinate mapping

    // Game state variables
    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let currentPiece = null;
    let nextPiece = null;
    let gameInterval = null;
    let isPaused = false;
    let isGameOver = false;
    let score = 0;
    let level = 1;
    let lines = 0;
    let dropSpeed = 1000; // milliseconds per drop
    let ghostEnabled = true;
    let boardPlaced = false;

    // HUD DOM elements
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const linesElement = document.getElementById('lines');
    const startButton = document.getElementById('start-btn');
    const pauseButton = document.getElementById('pause-btn');
    const restartButton = document.getElementById('restart-btn');
    const ghostToggle = document.getElementById('ghost-toggle');
    
    // Touch control buttons
    const moveLeftBtn = document.getElementById('move-left');
    const moveRightBtn = document.getElementById('move-right');
    const moveDownBtn = document.getElementById('move-down');
    const rotateBtn = document.getElementById('rotate');
    const hardDropBtn = document.getElementById('hard-drop');
    
    ghostToggle.addEventListener('change', () => {
      ghostEnabled = ghostToggle.checked;
      renderGhostPiece3D();
    });

    // Themes and tetromino shapes
    const THEMES = {
      classic: {
        I: 0x00FFFF, // cyan
        J: 0x0000FF, // blue
        L: 0xFFA500, // orange
        O: 0xFFFF00, // yellow
        S: 0x00FF00, // green
        T: 0x800080, // purple
        Z: 0xFF0000  // red
      }
    };
    const currentTheme = 'classic';

    const TETROMINOS = {
      I: { shape: [
          [0,0,0,0],
          [1,1,1,1],
          [0,0,0,0],
          [0,0,0,0]
        ] },
      J: { shape: [
          [1,0,0],
          [1,1,1],
          [0,0,0]
        ] },
      L: { shape: [
          [0,0,1],
          [1,1,1],
          [0,0,0]
        ] },
      O: { shape: [
          [1,1],
          [1,1]
        ] },
      S: { shape: [
          [0,1,1],
          [1,1,0],
          [0,0,0]
        ] },
      T: { shape: [
          [0,1,0],
          [1,1,1],
          [0,0,0]
        ] },
      Z: { shape: [
          [1,1,0],
          [0,1,1],
          [0,0,0]
        ] }
    };

    function getShapesWithThemeColors() {
      const shapes = {};
      const themeColors = THEMES[currentTheme];
      for (const key in TETROMINOS) {
        shapes[key] = {
          shape: TETROMINOS[key].shape,
          color: themeColors[key]
        };
      }
      return shapes;
    }
    let SHAPES = getShapesWithThemeColors();

    // --- Game logic functions ---
    function getRandomPiece() {
      const keys = Object.keys(SHAPES);
      const type = keys[Math.floor(Math.random() * keys.length)];
      // Deep-clone the shape and assign the appropriate color
      const tetromino = JSON.parse(JSON.stringify(SHAPES[type]));
      const pieceWidth = tetromino.shape[0].length;
      tetromino.position = { x: Math.floor((COLS - pieceWidth) / 2), y: 0 };
      return tetromino;
    }

    function isValidMove(piece, offsetX = 0, offsetY = 0) {
      const { shape, position } = piece;
      for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
          if (shape[row][col]) {
            const boardRow = position.y + row + offsetY;
            const boardCol = position.x + col + offsetX;
            if (boardCol < 0 || boardCol >= COLS || boardRow >= ROWS) return false;
            if (boardRow >= 0 && board[boardRow][boardCol]) return false;
          }
        }
      }
      return true;
    }

    function movePiece(offsetX, offsetY) {
      if (!currentPiece || isPaused || isGameOver) {
        log(`Move failed - Game state: ${isGameOver ? 'Game Over' : isPaused ? 'Paused' : !currentPiece ? 'No current piece' : 'Unknown'}`);
        return false;
      }
      
      if (isValidMove(currentPiece, offsetX, offsetY)) {
        currentPiece.position.x += offsetX;
        currentPiece.position.y += offsetY;
        updateScene();
        return true;
      }
      
      return false;
    }

    function rotatePiece() {
      if (!currentPiece || isPaused || isGameOver) return;
      const rotatedShape = [];
      for (let col = 0; col < currentPiece.shape[0].length; col++) {
        const newRow = [];
        for (let row = currentPiece.shape.length - 1; row >= 0; row--) {
          newRow.push(currentPiece.shape[row][col]);
        }
        rotatedShape.push(newRow);
      }
      const originalShape = currentPiece.shape;
      const originalPosition = { ...currentPiece.position };
      currentPiece.shape = rotatedShape;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      // Try wall kick: move right
      currentPiece.position.x += 1;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      // Try moving left instead
      currentPiece.position.x = originalPosition.x - 1;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      // Revert if no valid move
      currentPiece.shape = originalShape;
      currentPiece.position = originalPosition;
    }

    function hardDrop() {
      if (!currentPiece || isPaused || isGameOver) return;
      let dropDistance = 0;
      while (isValidMove(currentPiece, 0, dropDistance + 1)) {
        dropDistance++;
      }
      if (dropDistance > 0) {
        currentPiece.position.y += dropDistance;
        updateScene();
        lockPiece();
      }
    }

    function lockPiece() {
      log('Locking piece into board');
      
      const { shape, position, color } = currentPiece;
      shape.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
          if (value) {
            const boardRow = position.y + rowIndex;
            const boardCol = position.x + colIndex;
            if (boardRow >= 0 && boardRow < ROWS && boardCol >= 0 && boardCol < COLS) {
              board[boardRow][boardCol] = color;
            }
          }
        });
      });
      checkLines();
      currentPiece = nextPiece;
      nextPiece = getRandomPiece();
      updateScene();
      if (!isValidMove(currentPiece)) gameOver();
    }

    function checkLines() {
      let linesCleared = 0;
      for (let row = ROWS - 1; row >= 0; row--) {
        if (board[row].every(cell => cell !== 0)) {
          board.splice(row, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          row++;
        }
      }
      if (linesCleared > 0) {
        const pointValues = [0, 100, 300, 500, 800];
        score += pointValues[linesCleared] * level;
        lines += linesCleared;
        level = Math.floor(lines / 10) + 1;
        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
        
        log(`Cleared ${linesCleared} lines! Score: ${score}, Level: ${level}`);
        
        if (gameInterval) {
          clearInterval(gameInterval);
          gameInterval = setInterval(dropPiece, dropSpeed);
        }
      }
    }

    function dropPiece() {
      if (!currentPiece || isPaused || isGameOver) return;
      if (!movePiece(0, 1)) lockPiece();
    }

    function getGhostPosition() {
      if (!currentPiece) return null;
      // Clone current piece's position
      let ghost = JSON.parse(JSON.stringify(currentPiece));
      while (isValidMove(ghost, 0, 1)) {
        ghost.position.y += 1;
      }
      return ghost.position;
    }

    // --- Three.js AR scene setup ---
    log('Initializing Three.js and WebXR...');
    
    let scene, camera, renderer, controls;
    
    try {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        preserveDrawingBuffer: true // Helps with debugging
      });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      log(`Renderer created: ${renderer.domElement.width} x ${renderer.domElement.height}, Pixel Ratio: ${window.devicePixelRatio}`);
      
      try {
        renderer.xr.enabled = true;
        log('WebXR enabled on renderer');
      } catch (xrError) {
        log(`ERROR enabling XR: ${xrError.message}`);
      }
      
      document.body.appendChild(renderer.domElement);
      
      // Add fallback orbit controls for non-AR testing
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, -1);
      controls.enableDamping = true;
      controls.enabled = true;
      
      log('Orbit controls initialized');
    } catch (error) {
      log(`ERROR in Three.js setup: ${error.message}`);
    }
    
    // Check for WebXR support
    let xrSupported = false;
    if (navigator.xr) {
      navigator.xr.isSessionSupported('immersive-ar')
        .then(supported => {
          xrSupported = supported;
          log(`WebXR AR Support: ${supported ? 'Available' : 'Not Available'}`);
          
          if (supported) {
            addARButton();
          } else {
            log('WARNING: AR not supported, falling back to non-AR mode');
            // Still add a way to start in non-AR mode
            const nonARBtn = document.createElement('button');
            nonARBtn.textContent = 'Start in Non-AR Mode';
            nonARBtn.style.position = 'absolute';
            nonARBtn.style.bottom = '20px';
            nonARBtn.style.right = '20px';
            nonARBtn.style.padding = '12px';
            nonARBtn.style.fontSize = '16px';
            nonARBtn.addEventListener('click', () => {
              boardGroup.position.set(0, 0, -1);
              boardGroup.userData.placed = true;
              boardPlaced = true;
              updateScene();
              startGame();
            });
            document.body.appendChild(nonARBtn);
          }
        })
        .catch(err => {
          log(`ERROR checking AR support: ${err.message}`);
        });
    } else {
      log('ERROR: WebXR API not available in this browser');
    }
    
    function addARButton() {
      try {
        // Improved AR button with options for Quest 3
        const arButton = ARButton.createButton(renderer, { 
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay', 'hand-tracking'],
          domOverlay: { root: document.body },
          sessionInit: {
            environmentIntegration: true
          }
        });
        
        document.body.appendChild(arButton);
        log('AR Button added to document');
      } catch (err) {
        log(`ERROR adding AR button: ${err.message}`);
      }
    }

    // Better lighting for AR on Quest 3
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 2, 3);
    scene.add(directionalLight);
    
    log('Lighting set up');

    // Groups for the locked board cells, active falling piece, and ghost (shadow) piece
    const boardGroup = new THREE.Group();
    boardGroup.userData.placed = false;
    scene.add(boardGroup);
    
    // Adding board outline for better visibility in AR
    try {
      const boardOutlineGeometry = new THREE.BoxGeometry(
        COLS * cellSize, ROWS * cellSize, cellSize/10
      );
      boardOutlineGeometry.translate(0, boardHeight/2 - cellSize/2, -cellSize/10);
      
      const boardOutlineMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.3,
        wireframe: true
      });
      const boardOutline = new THREE.Mesh(boardOutlineGeometry, boardOutlineMaterial);
      boardGroup.add(boardOutline);
      
      // Add a ground plane for better visibility
      const groundGeometry = new THREE.PlaneGeometry(COLS * cellSize * 2, COLS * cellSize * 2);
      groundGeometry.rotateX(-Math.PI / 2);
      const groundMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x444444, 
        transparent: true, 
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.position.y = -0.01;
      boardGroup.add(ground);
      
      log('Board outline and ground plane created');
    } catch (error) {
      log(`ERROR creating board outline: ${error.message}`);
    }
    
    const activePieceGroup = new THREE.Group();
    scene.add(activePieceGroup);
    
    const ghostGroup = new THREE.Group();
    scene.add(ghostGroup);
    
    log('Scene groups initialized');

    // Improved reticle for AR hit testing
    let reticle;
    try {
      const geometry = new THREE.RingGeometry(0.05, 0.06, 32);
      geometry.rotateX(-Math.PI / 2);
      const material = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88,
        transparent: true,
        opacity: 0.8
      });
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
      
      log('Reticle created');
    } catch (error) {
      log(`ERROR creating reticle: ${error.message}`);
    }

    // Variables for AR hit testing
    let hitTestSource = null;
    let localSpace = null;
    let xrViewerPose = null;
    
    renderer.xr.addEventListener('sessionstart', async () => {
      log('XR Session Started!');
      
      const session = renderer.xr.getSession();
      
      try {
        // Set up hit testing
        const viewerSpace = await session.requestReferenceSpace('viewer');
        hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        localSpace = await session.requestReferenceSpace('local');
        
        log('Hit testing initialized successfully');
        
        // Disable non-AR controls when in AR
        controls.enabled = false;
        
        // Add event listener for select (trigger) input
        session.addEventListener('select', onSelect);
        log('XR select event listener added');
      } catch (error) {
        log(`ERROR during XR session setup: ${error.message}`);
      }
      
      updateStateInfo();
    });
    
    renderer.xr.addEventListener('sessionend', () => {
      log('XR Session Ended');
      hitTestSource = null;
      localSpace = null;
      controls.enabled = true;
      boardPlaced = false;
      boardGroup.userData.placed = false;
      updateStateInfo();
    });

    // Function to handle XR select event (trigger press)
    function onSelect() {
      log('XR Select Event Triggered');
      
      if (reticle.visible && !boardPlaced) {
        log('Placing board at hit test position');
        
        try {
          // Place the board at the hit test position
          const matrix = new THREE.Matrix4();
          matrix.fromArray(reticle.matrix.elements);
          
          const position = new THREE.Vector3();
          position.setFromMatrixPosition(matrix);
          
          boardGroup.position.copy(position);
          
          // Adjust the height to sit on the floor
          boardGroup.position.y += boardHeight / 2;
          boardGroup.userData.placed = true;
          boardPlaced = true;
          
          log(`Board placed at position: (${boardGroup.position.x.toFixed(2)}, ${boardGroup.position.y.toFixed(2)}, ${boardGroup.position.z.toFixed(2)})`);
          
          // Start game automatically when board is placed
          startGame();
        } catch (error) {
          log(`ERROR placing board: ${error.message}`);
        }
      } else {
        log(`Board placement failed: reticle visible: ${reticle.visible}, board already placed: ${boardPlaced}`);
      }
      
      updateStateInfo();
    }

    // --- Coordinate conversion ---
    // Convert board (grid) coordinates to world positions relative to boardGroup
    function boardToWorld(row, col) {
      const x = (col - COLS/2) * cellSize + cellSize/2;
      const y = boardHeight - row*cellSize - cellSize; // row=0 gives the highest y
      const z = 0;
      return new THREE.Vector3(x, y, z);
    }

    // --- 3D Rendering functions ---
    // Optimized rendering with instancing for better performance on Quest 3
    let instancedMeshes = {};
    
    function createInstancedMesh(color) {
      const colorKey = color.toString();
      if (!instancedMeshes[colorKey]) {
        const geometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, cellSize * 0.9);
        const material = new THREE.MeshStandardMaterial({ 
          color: color,
          roughness: 0.7,
          metalness: 0.2
        });
        instancedMeshes[colorKey] = { geometry, material };
      }
      return instancedMeshes[colorKey];
    }
    
    // Render the locked cells from the board array
    function renderBoard3D() {
      // Keep track of objects before and after to detect rendering issues
      const childrenBefore = boardGroup.children.length;
      
      try {
        // Remove all children except the first (the outline) and the second (ground plane)
        while(boardGroup.children.length > 2) {
          boardGroup.remove(boardGroup.children[2]);
        }
        
        // Group cells by color for better performance
        const colorGroups = {};
        
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            const colorValue = board[row][col];
            if (colorValue) {
              if (!colorGroups[colorValue]) {
                colorGroups[colorValue] = [];
              }
              colorGroups[colorValue].push({ row, col });
            }
          }
        }
        
        // Create instanced meshes for each color group
        for (const colorValue in colorGroups) {
          const cells = colorGroups[colorValue];
          const { geometry, material } = createInstancedMesh(colorValue);
          
          for (const cell of cells) {
            const pos = boardToWorld(cell.row, cell.col);
            const cube = new THREE.Mesh(geometry, material);
            cube.position.copy(pos);
            boardGroup.add(cube);
          }
        }
        
        const childrenAfter = boardGroup.children.length;
        log(`Board rendered: ${childrenAfter - 2} blocks (from ${childrenBefore} to ${childrenAfter} objects)`);
      } catch (error) {
        log(`ERROR rendering board: ${error.message}`);
      }
    }

    // Render the current falling tetromino
    function renderActivePiece3D() {
      try {
        while(activePieceGroup.children.length) {
          activePieceGroup.remove(activePieceGroup.children[0]);
        }
        
        if (!currentPiece) {
          log('No current piece to render');
          return;
        }
        
        const { shape, position, color } = currentPiece;
        const { geometry, material } = createInstancedMesh(color);
        
        // Position the active piece group at the board's position
        activePieceGroup.position.copy(boardGroup.position);
        
        let blocksAdded = 0;
        
        shape.forEach((rowArr, rowIndex) => {
