<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Tetris on Oculus Quest 3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    
    /* Debug panel */
    #debug-panel {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      max-height: 200px;
      overflow-y: auto;
    }
    
    #debug-log {
      font-family: monospace;
      font-size: 14px;
      white-space: pre-wrap;
      margin-bottom: 10px;
    }
    
    #state-info {
      font-size: 14px;
      margin-bottom: 10px;
      padding: 5px;
      border: 1px solid #555;
      background: rgba(0,0,0,0.3);
    }
    
    #debug-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    /* Simple HUD overlay for score and controls */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
    
    #hud > div { margin-bottom: 5px; }
    button { font-size: 16px; margin: 5px 0; padding: 8px 12px; }
    
    /* Make buttons more touch-friendly for Quest 3 */
    #control-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    
    #control-buttons button {
      min-height: 44px;
    }
    
    /* Extra visibility */
    #start-btn {
      background-color: #4CAF50;
      color: white;
      font-weight: bold;
      padding: 12px;
      min-width: 150px;
    }
    
    .debug-button {
      background-color: #ff9800;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    /* Permission Request */
    #permission-request {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
      color: white;
      text-align: center;
      z-index: 2000;
      display: none;
    }
    
    #xr-permission-btn {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 18px;
      margin-top: 15px;
      cursor: pointer;
    }
    
    /* Status indicator */
    #status-indicator {
      position: absolute;
      top: 10px; 
      right: 10px;
      padding: 5px 10px;
      border-radius: 5px;
      font-weight: bold;
      z-index: 1000;
    }
    
    .status-initializing {
      background-color: #FFC107;
      color: black;
    }
    
    .status-error {
      background-color: #F44336;
      color: white;
    }
    
    .status-ready {
      background-color: #4CAF50;
      color: white;
    }
  </style>
</head>
<body>
  <!-- Status indicator -->
  <div id="status-indicator" class="status-initializing">INITIALIZING...</div>
  
  <!-- Quick action button for immediate non-AR play -->
  <div id="quick-start" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
       background-color: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; 
       text-align: center; color: white; z-index: 3000;">
    <h2>AR Tetris</h2>
    <p>Initialization taking too long?</p>
    <button id="skip-ar-btn" style="background-color: #4CAF50; color: white; 
           padding: 15px 30px; border: none; border-radius: 5px; font-size: 18px; 
           margin-top: 15px; cursor: pointer;">
      Play in Non-AR Mode
    </button>
  </div>
  
  <!-- Permission request dialog -->
  <div id="permission-request">
    <h2>WebXR Permission Required</h2>
    <p>This game needs access to AR features to work properly on your Oculus Quest 3.</p>
    <p>Click the button below to grant permission.</p>
    <button id="xr-permission-btn">Enable AR Features</button>
  </div>
  
  <!-- Heads-up display overlay -->
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Lines: <span id="lines">0</span></div>
    <button id="start-btn">Start Game (Non-AR)</button>
    <button id="pause-btn">Pause</button>
    <button id="restart-btn">Restart</button>
    <div>
      <input type="checkbox" id="ghost-toggle" checked>
      <label for="ghost-toggle">Show Ghost</label>
    </div>
    
    <!-- Touch controls for Quest 3 -->
    <div id="control-buttons">
      <button id="move-left">←</button>
      <button id="rotate">↻</button>
      <button id="move-right">→</button>
      <button id="move-down">↓</button>
      <button id="hard-drop">Drop</button>
    </div>
  </div>
  
  <!-- Debug panel -->
  <div id="debug-panel">
    <div id="state-info">Initialization State: Starting...</div>
    <div id="debug-log">Debug log initialized. Startup sequence beginning...</div>
    <div id="debug-controls">
      <button class="debug-button" id="debug-start-game">Force Start Game</button>
      <button class="debug-button" id="debug-place-board">Force Place Board</button>
      <button class="debug-button" id="check-permissions">Check Permissions</button>
      <button class="debug-button" id="check-xr">Check XR Status</button>
      <button class="debug-button" id="fallback-mode">Enter Fallback Mode</button>
      <button class="debug-button" id="toggle-debug">Hide Debug</button>
      <button class="debug-button" id="clear-log">Clear Log</button>
    </div>
  </div>

  <!-- Three.js and AR code -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // Debug utilities
    const debugLog = document.getElementById('debug-log');
    const stateInfo = document.getElementById('state-info');
    const toggleDebugBtn = document.getElementById('toggle-debug');
    const clearLogBtn = document.getElementById('clear-log');
    const checkPermissionsBtn = document.getElementById('check-permissions');
    const checkXRBtn = document.getElementById('check-xr');
    const fallbackModeBtn = document.getElementById('fallback-mode');
    const debugPlaceBoardBtn = document.getElementById('debug-place-board');
    const debugStartGameBtn = document.getElementById('debug-start-game');
    const debugPanel = document.getElementById('debug-panel');
    const statusIndicator = document.getElementById('status-indicator');
    const permissionRequest = document.getElementById('permission-request');
    const xrPermissionBtn = document.getElementById('xr-permission-btn');
    const quickStartPanel = document.getElementById('quick-start');
    const skipARBtn = document.getElementById('skip-ar-btn');
    
    let logMessages = [];
    const MAX_LOG_MESSAGES = 30;
    
    // Status tracking
    let initStage = 'starting';
    let startButtonClicked = false;
    let xrPermissionGranted = false;
    let fallbackMode = false;
    
    function setStatus(status, message) {
      statusIndicator.className = `status-${status}`;
      statusIndicator.textContent = message;
      log(`STATUS CHANGE: ${message}`);
    }
    
    function log(message) {
      console.log(message); // Also log to browser console
      const timestamp = new Date().toLocaleTimeString();
      logMessages.push(`[${timestamp}] ${message}`);
      
      // Keep log size manageable
      if (logMessages.length > MAX_LOG_MESSAGES) {
        logMessages.shift();
      }
      
      debugLog.textContent = logMessages.join('\n');
      debugLog.scrollTop = debugLog.scrollHeight; // Auto-scroll to bottom
    }
    
    function updateStateInfo() {
      let stateText = `INIT STAGE: ${initStage}\n`;
      stateText += `Start Button Clicked: ${startButtonClicked ? 'YES' : 'NO'}\n`;
      stateText += `XR Available: ${navigator.xr ? 'YES' : 'NO'}\n`;
      stateText += `XR Permission: ${xrPermissionGranted ? 'GRANTED' : 'UNKNOWN'}\n`;
      stateText += `XR Session Active: ${(renderer && renderer.xr && renderer.xr.isPresenting) ? 'YES' : 'NO'}\n`;
      stateText += `Fallback Mode: ${fallbackMode ? 'YES' : 'NO'}\n`;
      stateText += `Board Placed: ${boardPlaced ? 'YES' : 'NO'}\n`;
      stateText += `Game State: ${isGameOver ? 'Game Over' : isPaused ? 'Paused' : gameInterval ? 'Running' : 'Stopped'}\n`;
      stateText += `Current Piece: ${currentPiece ? 'YES' : 'NO'}\n`;
      stateText += `Renderer: ${renderer ? 'Created' : 'Not Created'}\n`;
      stateText += `Hit Test Source: ${hitTestSource ? 'Available' : 'Not Available'}\n`;
      stateText += `Board Group Position: ${boardGroup ? `(${boardGroup.position.x.toFixed(2)}, ${boardGroup.position.y.toFixed(2)}, ${boardGroup.position.z.toFixed(2)})` : 'N/A'}\n`;
      
      stateInfo.textContent = stateText;
    }
    
    // Debug panel controls
    toggleDebugBtn.addEventListener('click', () => {
      debugPanel.style.display = 'none';
      
      // Add a small button to show debug again
      const showDebugBtn = document.createElement('button');
      showDebugBtn.textContent = 'Show Debug';
      showDebugBtn.style.position = 'absolute';
      showDebugBtn.style.bottom = '10px';
      showDebugBtn.style.left = '10px';
      showDebugBtn.style.zIndex = '2000';
      showDebugBtn.onclick = () => {
        debugPanel.style.display = 'block';
        document.body.removeChild(showDebugBtn);
      };
      document.body.appendChild(showDebugBtn);
    });
    
    clearLogBtn.addEventListener('click', () => {
      logMessages = ['Log cleared.'];
      debugLog.textContent = 'Log cleared.';
    });
    
    checkPermissionsBtn.addEventListener('click', () => {
      log('Checking device permissions...');
      
      // Check XR permissions
      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then(supported => {
            log(`AR Session Support: ${supported ? 'YES' : 'NO'}`);
            
            if (supported) {
              log('Attempting to request temporary XR session to check permissions...');
              navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
              }).then(session => {
                log('SUCCESS: XR session created temporarily - permissions granted');
                xrPermissionGranted = true;
                updateStateInfo();
                session.end(); // End the temporary session right away
              }).catch(err => {
                log(`PERMISSION ERROR: ${err.message}`);
                // Show permission request UI
                permissionRequest.style.display = 'block';
              });
            }
          });
      } else {
        log('ERROR: WebXR API not available on this device/browser');
      }
      
      // Check camera permissions if needed
      if (navigator.permissions) {
        navigator.permissions.query({ name: 'camera' })
          .then(permissionStatus => {
            log(`Camera Permission: ${permissionStatus.state.toUpperCase()}`);
          })
          .catch(err => {
            log(`ERROR checking camera permission: ${err.message}`);
          });
      }
      
      updateStateInfo();
    });
    
    checkXRBtn.addEventListener('click', () => {
      log('Checking WebXR status...');
      
      if (!navigator.xr) {
        log('ERROR: WebXR API not available in this browser/device');
        return;
      }
      
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        log(`AR Session Support: ${supported ? 'YES' : 'NO'}`);
      });
      
      // Report additional info
      log(`Window Dimensions: ${window.innerWidth}x${window.innerHeight}`);
      log(`Device Pixel Ratio: ${window.devicePixelRatio}`);
      
      if (renderer) {
        log(`XR Session Active: ${renderer.xr.isPresenting ? 'YES' : 'NO'}`);
        log(`Canvas Size: ${renderer.domElement.width}x${renderer.domElement.height}`);
      } else {
        log('ERROR: Renderer not initialized');
      }
      
      log(`User Agent: ${navigator.userAgent}`);
      
      updateStateInfo();
    });
    
    fallbackModeBtn.addEventListener('click', () => {
      log('Entering fallback (non-AR) mode...');
      fallbackMode = true;
      
      if (renderer && camera) {
        // Set up for non-AR viewing
        camera.position.set(0, 0.5, 2);
        if (controls) {
          controls.target.set(0, 0, -1);
          controls.update();
        }
        
        // Position board directly in front
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        
        setStatus('ready', 'FALLBACK MODE');
        
        log('Board positioned for fallback mode');
        updateScene();
        startGame();
      } else {
        log('ERROR: Cannot enter fallback mode, renderer not initialized');
      }
      
      updateStateInfo();
    });
    
    debugPlaceBoardBtn.addEventListener('click', () => {
      log('Manually placing board...');
      
      if (boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        log('Board manually placed at position (0, 0, -1)');
        updateScene();
      } else {
        log('ERROR: Board group not initialized');
      }
      
      updateStateInfo();
    });
    
    debugStartGameBtn.addEventListener('click', () => {
      log('Forcing game start...');
      startButtonClicked = true;
      
      // Make sure board is placed
      if (!boardPlaced && boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
      }
      
      startGame();
      updateStateInfo();
    });
    
    // Permission request button
    xrPermissionBtn.addEventListener('click', () => {
      log('User clicked XR permission button');
      permissionRequest.style.display = 'none';
      
      // Try to request AR session
      if (navigator.xr) {
        navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        }).then(session => {
          log('XR permission granted!');
          xrPermissionGranted = true;
          session.end(); // End the session right away, we'll start a proper one later
          
          // Refresh the AR button
          if (document.querySelector('.webxr-button')) {
            document.querySelector('.webxr-button').click();
          } else {
            addARButton(); // Try to add the AR button again
          }
        }).catch(err => {
          log(`ERROR: Failed to get XR permission: ${err.message}`);
          setStatus('error', 'AR UNAVAILABLE');
        });
      }
    });

    // --- Game configuration and state ---
    log('Initializing game configuration...');
    initStage = 'game_config';
    updateStateInfo();
    
    const cellSize = 0.05; // world units per Tetris cell
    const COLS = 10, ROWS = 20;
    const boardHeight = ROWS * cellSize; // used for coordinate mapping

    // Game state variables
    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let currentPiece = null;
    let nextPiece = null;
    let gameInterval = null;
    let isPaused = false;
    let isGameOver = false;
    let score = 0;
    let level = 1;
    let lines = 0;
    let dropSpeed = 1000; // milliseconds per drop
    let ghostEnabled = true;
    let boardPlaced = false;

    // HUD DOM elements
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const linesElement = document.getElementById('lines');
    const startButton = document.getElementById('start-btn');
    const pauseButton = document.getElementById('pause-btn');
    const restartButton = document.getElementById('restart-btn');
    const ghostToggle = document.getElementById('ghost-toggle');
    
    // Touch control buttons
    const moveLeftBtn = document.getElementById('move-left');
    const moveRightBtn = document.getElementById('move-right');
    const moveDownBtn = document.getElementById('move-down');
    const rotateBtn = document.getElementById('rotate');
    const hardDropBtn = document.getElementById('hard-drop');
    
    ghostToggle.addEventListener('change', () => {
      ghostEnabled = ghostToggle.checked;
      renderGhostPiece3D();
    });

    // Themes and tetromino shapes
    const THEMES = {
      classic: {
        I: 0x00FFFF, // cyan
        J: 0x0000FF, // blue
        L: 0xFFA500, // orange
        O: 0xFFFF00, // yellow
        S: 0x00FF00, // green
        T: 0x800080, // purple
        Z: 0xFF0000  // red
      }
    };
    const currentTheme = 'classic';

    const TETROMINOS = {
      I: { shape: [
          [0,0,0,0],
          [1,1,1,1],
          [0,0,0,0],
          [0,0,0,0]
        ] },
      J: { shape: [
          [1,0,0],
          [1,1,1],
          [0,0,0]
        ] },
      L: { shape: [
          [0,0,1],
          [1,1,1],
          [0,0,0]
        ] },
      O: { shape: [
          [1,1],
          [1,1]
        ] },
      S: { shape: [
          [0,1,1],
          [1,1,0],
          [0,0,0]
        ] },
      T: { shape: [
          [0,1,0],
          [1,1,1],
          [0,0,0]
        ] },
      Z: { shape: [
          [1,1,0],
          [0,1,1],
          [0,0,0]
        ] }
    };

    function getShapesWithThemeColors() {
      const shapes = {};
      const themeColors = THEMES[currentTheme];
      for (const key in TETROMINOS) {
        shapes[key] = {
          shape: TETROMINOS[key].shape,
          color: themeColors[key]
        };
      }
      return shapes;
    }
    let SHAPES = getShapesWithThemeColors();
    
    log('Game configuration initialized');

    // --- Game logic functions ---
    function getRandomPiece() {
      try {
        const keys = Object.keys(SHAPES);
        const type = keys[Math.floor(Math.random() * keys.length)];
        // Deep-clone the shape and assign the appropriate color
        const tetromino = JSON.parse(JSON.stringify(SHAPES[type]));
        const pieceWidth = tetromino.shape[0].length;
        tetromino.position = { x: Math.floor((COLS - pieceWidth) / 2), y: 0 };
        return tetromino;
      } catch (error) {
        log(`ERROR generating piece: ${error.message}`);
        // Return a simple fallback piece if something goes wrong
        return {
          shape: [[1,1], [1,1]],
          color: 0xFFFF00,
          position: { x: 4, y: 0 }
        };
      }
    }

    function isValidMove(piece, offsetX = 0, offsetY = 0) {
      if (!piece || !piece.shape) {
        log('ERROR: Invalid piece in isValidMove');
        return false;
      }
      
      const { shape, position } = piece;
      for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
          if (shape[row][col]) {
            const boardRow = position.y + row + offsetY;
            const boardCol = position.x + col + offsetX;
            if (boardCol < 0 || boardCol >= COLS || boardRow >= ROWS) return false;
            if (boardRow >= 0 && board[boardRow][boardCol]) return false;
          }
        }
      }
      return true;
    }

    function movePiece(offsetX, offsetY) {
      if (!currentPiece || isPaused || isGameOver) {
        log(`Move failed - Game state: ${isGameOver ? 'Game Over' : isPaused ? 'Paused' : !currentPiece ? 'No current piece' : 'Unknown'}`);
        return false;
      }
      
      if (isValidMove(currentPiece, offsetX, offsetY)) {
        currentPiece.position.x += offsetX;
        currentPiece.position.y += offsetY;
        updateScene();
        return true;
      }
      
      return false;
    }

    function rotatePiece() {
      if (!currentPiece || isPaused || isGameOver) return;
      const rotatedShape = [];
      for (let col = 0; col < currentPiece.shape[0].length; col++) {
        const newRow = [];
        for (let row = currentPiece.shape.length - 1; row >= 0; row--) {
          newRow.push(currentPiece.shape[row][col]);
        }
        rotatedShape.push(newRow);
      }
      const originalShape = currentPiece.shape;
      const originalPosition = { ...currentPiece.position };
      currentPiece.shape = rotatedShape;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      // Try wall kick: move right
      currentPiece.position.x += 1;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      // Try moving left instead
      currentPiece.position.x = originalPosition.x - 1;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      // Revert if no valid move
      currentPiece.shape = originalShape;
      currentPiece.position = originalPosition;
    }

    function hardDrop() {
      if (!currentPiece || isPaused || isGameOver) return;
      let dropDistance = 0;
      while (isValidMove(currentPiece, 0, dropDistance + 1)) {
        dropDistance++;
      }
      if (dropDistance > 0) {
        currentPiece.position.y += dropDistance;
        updateScene();
        lockPiece();
      }
    }

    function lockPiece() {
      log('Locking piece into board');
      
      if (!currentPiece) {
        log('ERROR: No current piece to lock');
        return;
      }
      
      const { shape, position, color } = currentPiece;
      shape.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
          if (value) {
            const boardRow = position.y + rowIndex;
            const boardCol = position.x + colIndex;
            if (boardRow >= 0 && boardRow < ROWS && boardCol >= 0 && boardCol < COLS) {
              board[boardRow][boardCol] = color;
            }
          }
        });
      });
      checkLines();
      currentPiece = nextPiece;
      nextPiece = getRandomPiece();
      updateScene();
      if (!isValidMove(currentPiece)) gameOver();
    }

    function checkLines() {
      let linesCleared = 0;
      for (let row = ROWS - 1; row >= 0; row--) {
        if (board[row].every(cell => cell !== 0)) {
          board.splice(row, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          row++;
        }
      }
      if (linesCleared > 0) {
        const pointValues = [0, 100, 300, 500, 800];
        score += pointValues[linesCleared] * level;
        lines += linesCleared;
        level = Math.floor(lines / 10) + 1;
        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
        
        log(`Cleared ${linesCleared} lines! Score: ${score}, Level: ${level}`);
        
        if (gameInterval) {
          clearInterval(gameInterval);
          gameInterval = setInterval(dropPiece, dropSpeed);
        }
      }
    }

    function dropPiece() {
      if (!currentPiece || isPaused || isGameOver) return;
      if (!movePiece(0, 1)) lockPiece();
    }

    function getGhostPosition() {
      if (!currentPiece) return null;
      // Clone current piece's position
      let ghost = JSON.parse(JSON.stringify(currentPiece));
      while (isValidMove(ghost, 0, 1)) {
        ghost.position.y += 1;
      }
      return ghost.position;
    }

    // --- Three.js AR scene setup ---
    log('Initializing Three.js...');
    initStage = 'three_setup';
    updateStateInfo();
    setStatus('initializing', 'SETTING UP THREE.JS');
    
    let scene, camera, renderer, controls;
    let hitTestSource = null;
    let localSpace = null;
    let reticle = null;
    let boardGroup, activePieceGroup, ghostGroup;
    
    try {
      // Initialize Scene
      scene = new THREE.Scene();
      log('Scene created');
      
      // Initialize Camera
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      log('Camera created');
      
      // Initialize Renderer
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        preserveDrawingBuffer: true
      });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      log(`Renderer created: ${renderer.domElement.width}x${renderer.domElement.height}, Pixel Ratio: ${window.devicePixelRatio}`);
      
      // Try to enable WebXR
      try {
        renderer.xr.enabled = true;
        log('WebXR enabled on renderer');
      } catch (xrError) {
        log(`ERROR enabling XR: ${xrError.message}`);
        setStatus('error', 'XR ERROR');
      }
      
      // Add renderer to document
      document.body.appendChild(renderer.domElement);
      log('Renderer added to document');
      
      // Add controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, -1);
      controls.enableDamping = true;
      controls.enabled = true;
      log('Orbit controls initialized');
      
      // Set camera position for non-AR viewing
      camera.position.set(0, 0.5, 2);
      controls.update();
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 2, 3);
      scene.add(directionalLight);
      log('Lighting set up');
      
      // Create groups for game elements
      boardGroup = new THREE.Group();
      boardGroup.userData.placed = false;
      scene.add(boardGroup);
      log('Board group created');
      
      activePieceGroup = new THREE.Group();
      scene.add(activePieceGroup);
      
      ghostGroup = new THREE.Group();
      scene.add(ghostGroup);
      log('Game element groups created');
      
      // Create board outline
      const boardOutlineGeometry = new THREE.BoxGeometry(
        COLS * cellSize, ROWS * cellSize, cellSize/10
      );
      boardOutlineGeometry.translate(0, boardHeight/2 - cellSize/2, -cellSize/10);
      
      const boardOutlineMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.5,
        wireframe: true
      });
      
      const boardOutline = new THREE.Mesh(boardOutlineGeometry, boardOutlineMaterial);
      boardGroup.add(boardOutline);
      log('Board outline created');
      
      // Create ground plane
      const groundGeometry = new THREE.PlaneGeometry(COLS * cellSize * 2, COLS * cellSize * 2);
      groundGeometry.rotateX(-Math.PI / 2);
      const groundMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x444444, 
        transparent: true, 
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.position.y = -0.01;
      boardGroup.add(ground);
      log('Ground plane created');
      
      // Create reticle for hit testing
      const reticleGeometry = new THREE.RingGeometry(0.05, 0.06, 32);
      reticleGeometry.rotateX(-Math.PI / 2);
      const reticleMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88,
        transparent: true,
        opacity: 0.8
      });
      reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
      log('Reticle created');
      
      // Everything initialized successfully
      log('Three.js setup complete');
      initStage = 'xr_setup';
      updateStateInfo();
      
    } catch (error) {
      log(`CRITICAL ERROR in Three.js setup: ${error.message}`);
      console.error(error);
      setStatus('error', 'SETUP ERROR');
    }
    
    // Quick start button (skip AR)
    skipARBtn.addEventListener('click', () => {
      log('User clicked Skip AR button');
      quickStartPanel.style.display = 'none';
      
      // Force non-AR mode immediately
      fallbackMode = true;
      setStatus('ready', 'NON-AR MODE');
      
      if (boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
      }
      
      // Start the game
      setTimeout(() => {
        startGame();
      }, 100);
    });
    
    // Set a timeout to auto-hide the quick start panel if initialization succeeds
    setTimeout(() => {
      if (initStage === 'ready' || fallbackMode) {
        quickStartPanel.style.display = 'none';
      }
    }, 10000);
    
    // Check for WebXR support
    log('Checking WebXR support...');
    try {
      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then(supported => {
            log(`WebXR AR Support: ${supported ? 'YES' : 'NO'}`);
            
            // Hide quick start once we know AR status
            setTimeout(() => {
              quickStartPanel.style.display = 'none';
            }, 2000);
            
            if (supported) {
              log('Adding AR button...');
              addARButton();
              setStatus('initializing', 'READY - TAP AR BUTTON');
            } else {
              log('AR not supported, entering fallback mode');
              fallbackMode = true;
              setStatus('ready', 'FALLBACK MODE');
              
              // Set up for non-AR mode
              boardGroup.position.set(0, 0, -1);
              boardGroup.userData.placed = true;
              boardPlaced = true;
              updateScene();
            }
            
            initStage = 'ready';
            updateStateInfo();
          })
          .catch(err => {
            log(`ERROR checking AR support: ${err.message}`);
            fallbackMode = true;
            setStatus('error', 'XR ERROR - FALLBACK MODE');
            
            // Set up for non-AR mode
            boardGroup.position.set(0, 0, -1);
            boardGroup.userData.placed = true;
            boardPlaced = true;
          });
      } else {
        log('WebXR API not available, entering fallback mode');
        fallbackMode = true;
        setStatus('ready', 'FALLBACK MODE');
        
        // Hide quick start after 2 seconds
        setTimeout(() => {
          quickStartPanel.style.display = 'none';
        }, 2000);
        
        // Set up for non-AR mode
        if (boardGroup) {
          boardGroup.position.set(0, 0, -1);
          boardGroup.userData.placed = true;
          boardPlaced = true;
          updateScene();
        }
      }
    } catch (error) {
      log(`CRITICAL ERROR checking WebXR: ${error.message}`);
      fallbackMode = true;
      setStatus('error', 'CRITICAL ERROR - FALLBACK MODE');
      
      // Set up for non-AR mode
      if (boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        updateScene();
      }
    }
    
    function addARButton() {
      try {
        // Create AR button with more options for Quest 3
        const arButton = ARButton.createButton(renderer, { 
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay', 'hand-tracking'],
          domOverlay: { root: document.body },
          sessionInit: {
            environmentIntegration: true
          }
        });
        
        // Style the AR button for better visibility
        arButton.style.padding = '12px 24px';
        arButton.style.fontSize = '16px';
        arButton.style.fontWeight = 'bold';
        arButton.style.backgroundColor = '#4285F4';
        
        document.body.appendChild(arButton);
        log('AR Button added to document');
        
        // Update start button to indicate AR mode is available
        startButton.textContent = 'Start Game (Non-AR)';
      } catch (err) {
        log(`ERROR adding AR button: ${err.message}`);
        setStatus('error', 'AR BUTTON ERROR');
      }
    }

    // Set up WebXR session events
    if (renderer) {
      renderer.xr.addEventListener('sessionstart', async () => {
        log('XR Session Started!');
        setStatus('initializing', 'AR SESSION ACTIVE');
        
        const session = renderer.xr.getSession();
        
        try {
          // Set up hit testing
          const viewerSpace = await session.requestReferenceSpace('viewer');
          hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
          localSpace = await session.requestReferenceSpace('local');
          
          log('Hit testing initialized successfully');
          
          // Disable non-AR controls when in AR
          controls.enabled = false;
          
          // Add event listener for select (trigger) input
          session.addEventListener('select', onSelect);
          log('XR select event listener added');
          
          setStatus('ready', 'POINT AND TAP TO PLACE');
        } catch (error) {
          log(`ERROR during XR session setup: ${error.message}`);
          setStatus('error', 'AR SESSION ERROR');
        }
        
        updateStateInfo();
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        log('XR Session Ended');
        setStatus('ready', 'AR SESSION ENDED');
        
        hitTestSource = null;
        localSpace = null;
        controls.enabled = true;
        
        // Don't reset the board and game if we're already playing
        if (!gameInterval) {
          boardPlaced = false;
          boardGroup.userData.placed = false;
        }
        
        updateStateInfo();
      });
    }

    // Function to handle XR select event (trigger press)
    function onSelect() {
      log('XR Select Event Triggered');
      
      if (reticle.visible && !boardPlaced) {
        log('Placing board at hit test position');
        
        try {
          // Place the board at the hit test position
          const matrix = new THREE.Matrix4();
          matrix.fromArray(reticle.matrix.elements);
          
          const position = new THREE.Vector3();
          position.setFromMatrixPosition(matrix);
          
          boardGroup.position.copy(position);
          
          // Adjust the height to sit on the floor
          boardGroup.position.y += boardHeight / 2;
          boardGroup.userData.placed = true;
          boardPlaced = true;
          
          log(`Board placed at position: (${boardGroup.position.x.toFixed(2)}, ${boardGroup.position.y.toFixed(2)}, ${boardGroup.position.z.toFixed(2)})`);
          setStatus('ready', 'BOARD PLACED');
          
          // Start game automatically when board is placed
          startGame();
        } catch (error) {
          log(`ERROR placing board: ${error.message}`);
        }
      } else {
        log(`Board placement skipped: reticle visible: ${reticle ? reticle.visible : 'no reticle'}, board already placed: ${boardPlaced}`);
      }
      
      updateStateInfo();
    }

    // --- Coordinate conversion ---
    // Convert board (grid) coordinates to world positions relative to boardGroup
    function boardToWorld(row, col) {
      const x = (col - COLS/2) * cellSize + cellSize/2;
      const y = boardHeight - row*cellSize - cellSize; // row=0 gives the highest y
      const z = 0;
      return new THREE.Vector3(x, y, z);
    }

    // --- 3D Rendering functions ---
    // Optimized rendering with instancing for better performance on Quest 3
    let instancedMeshes = {};
    
    function createInstancedMesh(color) {
      const colorKey = color.toString();
      if (!instancedMeshes[colorKey]) {
        const geometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, cellSize * 0.9);
        const material = new THREE.MeshStandardMaterial({ 
          color: color,
          roughness: 0.7,
          metalness: 0.2
        });
        instancedMeshes[colorKey] = { geometry, material };
      }
      return instancedMeshes[colorKey];
    }
    
    // Render the locked cells from the board array
    function renderBoard3D() {
      try {
        // Keep track of objects before and after to detect rendering issues
        const childrenBefore = boardGroup ? boardGroup.children.length : 0;
        
        // Remove all children except the first (the outline) and the second (ground plane)
        if (boardGroup) {
          while(boardGroup.children.length > 2) {
            boardGroup.remove(boardGroup.children[2]);
          }
          
          // Group cells by color for better performance
          const colorGroups = {};
          
          for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
              const colorValue = board[row][col];
              if (colorValue) {
                if (!colorGroups[colorValue]) {
                  colorGroups[colorValue] = [];
                }
                colorGroups[colorValue].push({ row, col });
              }
            }
          }
          
          // Create instanced meshes for each color group
          for (const colorValue in colorGroups) {
            const cells = colorGroups[colorValue];
            const { geometry, material } = createInstancedMesh(colorValue);
            
            for (const cell of cells) {
              const pos = boardToWorld(cell.row, cell.col);
              const cube = new THREE.Mesh(geometry, material);
              cube.position.copy(pos);
              boardGroup.add(cube);
            }
          }
          
          const childrenAfter = boardGroup.children.length;
          if (childrenAfter > childrenBefore) {
            log(`Board rendered: ${childrenAfter - 2} blocks`);
          }
        } else {
          log('ERROR: boardGroup is undefined in renderBoard3D');
        }
      } catch (error) {
        log(`ERROR rendering board: ${error.message}`);
      }
    }

    // Render the current falling tetromino
    function renderActivePiece3D() {
      try {
        if (activePieceGroup) {
          while(activePieceGroup.children.length) {
            activePieceGroup.remove(activePieceGroup.children[0]);
          }
          
          if (!currentPiece) {
            //log('No current piece to render');
            return;
          }
          
          const { shape, position, color } = currentPiece;
          const { geometry, material } = createInstancedMesh(color);
          
          // Position the active piece group at the board's position
          if (boardGroup) {
            activePieceGroup.position.copy(boardGroup.position);
          }
          
          let blocksAdded = 0;
          
          shape.forEach((rowArr, rowIndex) => {
            rowArr.forEach((value, colIndex) => {
              if (value) {
                const boardRow = position.y + rowIndex;
                const boardCol = position.x + colIndex;
                const pos = boardToWorld(boardRow, boardCol);
                const cube = new THREE.Mesh(geometry, material);
                cube.position.copy(pos);
                activePieceGroup.add(cube);
                blocksAdded++;
              }
            });
          });
          
          if (blocksAdded > 0) {
            //log(`Active piece rendered with ${blocksAdded} blocks`);
          }
        } else {
          log('ERROR: activePieceGroup is undefined in renderActivePiece3D');
        }
      } catch (error) {
        log(`ERROR rendering active piece: ${error.message}`);
      }
    }

    // Render the ghost piece (a transparent preview of where the piece will land)
    function renderGhostPiece3D() {
      try {
        if (ghostGroup) {
          while(ghostGroup.children.length) {
            ghostGroup.remove(ghostGroup.children[0]);
          }
          
          if (!currentPiece || !ghostEnabled) return;
          
          const ghostPos = getGhostPosition();
          const { shape, color } = currentPiece;
          
          // Create a semi-transparent material for ghost piece
          const geometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, cellSize * 0.9);
          const material = new THREE.MeshStandardMaterial({ 
            color: color, 
            transparent: true, 
            opacity: 0.3,
            wireframe: false
          });
          
          // Position the ghost group at the board's position
          if (boardGroup) {
            ghostGroup.position.copy(boardGroup.position);
          }
          
          shape.forEach((rowArr, rowIndex) => {
            rowArr.forEach((value, colIndex) => {
              if (value) {
                const boardRow = ghostPos.y + rowIndex;
                const boardCol = ghostPos.x + colIndex;
                const pos = boardToWorld(boardRow, boardCol);
                const cube = new THREE.Mesh(geometry, material);
                cube.position.copy(pos);
                ghostGroup.add(cube);
              }
            });
          });
        } else {
          log('ERROR: ghostGroup is undefined in renderGhostPiece3D');
        }
      } catch (error) {
        log(`ERROR rendering ghost piece: ${error.message}`);
      }
    }

    // Update all three groups based on current game state
    function updateScene() {
      renderBoard3D();
      renderActivePiece3D();
      renderGhostPiece3D();
    }

    // --- User input handling ---
    function handleKeydown(event) {
      if (isPaused || isGameOver) return;
      switch(event.key) {
        case 'ArrowLeft': movePiece(-1, 0); break;
        case 'ArrowRight': movePiece(1, 0); break;
        case 'ArrowDown': movePiece(0, 1); break;
        case 'ArrowUp': rotatePiece(); break;
        case ' ': case 'Spacebar': hardDrop(); break;
      }
    }
    document.addEventListener('keydown', handleKeydown);
    
    // Add touch controls for Oculus controllers
    moveLeftBtn.addEventListener('click', () => {
      log('Left button pressed');
      movePiece(-1, 0);
    });
    
    moveRightBtn.addEventListener('click', () => {
      log('Right button pressed');
      movePiece(1, 0);
    });
    
    moveDownBtn.addEventListener('click', () => {
      log('Down button pressed');
      movePiece(0, 1);
    });
    
    rotateBtn.addEventListener('click', () => {
      log('Rotate button pressed');
      rotatePiece();
    });
    
    hardDropBtn.addEventListener('click', () => {
      log('Hard drop button pressed');
      hardDrop();
    });

    // --- Game control functions ---
    function startGame() {
      try {
        log('Starting game...');
        startButtonClicked = true;
        
        if (gameInterval) {
          log('Clearing existing game interval');
          clearInterval(gameInterval);
        }
        
        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        score = 0;
        level = 1;
        lines = 0;
        dropSpeed = 1000;
        isPaused = false;
        isGameOver = false;
        
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
        
        // Hide quick start panel if it's still visible
        if (quickStartPanel) {
          quickStartPanel.style.display = 'none';
        }
        
        log('Creating pieces');
        currentPiece = getRandomPiece();
        nextPiece = getRandomPiece();
        
        // Make sure the board is placed in non-AR mode
        if ((!renderer.xr.isPresenting || fallbackMode) && 
            (!boardGroup.userData.placed || !boardPlaced)) {
          log('Setting up board for non-AR mode');
          camera.position.set(0, 1, 2);
          if (controls) controls.update();
          boardGroup.position.set(0, 0, -1);
          boardGroup.userData.placed = true;
          boardPlaced = true;
        }
        
        log('Updating scene');
        updateScene();
        
        // Create a visible test cube to verify rendering is working
        const testCube = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.1, 0.1),
          new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        testCube.position.set(0, 0, -1);
        scene.add(testCube);
        log('Added test cube for visibility check');
        
        log('Starting game interval');
        gameInterval = setInterval(dropPiece, dropSpeed);
        
        // Show a confirmation message
        const startMessage = document.createElement('div');
        startMessage.style.position = 'absolute';
        startMessage.style.top = '50%';
        startMessage.style.left = '50%';
        startMessage.style.transform = 'translate(-50%, -50%)';
        startMessage.style.background = 'rgba(0,0,0,0.7)';
        startMessage.style.color = 'white';
        startMessage.style.padding = '20px';
        startMessage.style.borderRadius = '10px';
        startMessage.style.fontSize = '24px';
        startMessage.style.zIndex = '1000';
        startMessage.innerHTML = 'Game Started!';
        document.body.appendChild(startMessage);
        
        setTimeout(() => {
          document.body.removeChild(startMessage);
        }, 2000);
        
        log('Game started successfully');
        setStatus('ready', 'GAME STARTED');
        updateStateInfo();
      } catch (error) {
        log(`ERROR starting game: ${error.message}`);
        console.error(error);
        setStatus('error', 'START ERROR');
        
        // Show error to user
        alert(`Error starting game: ${error.message}. Check debug panel for details.`);
      }
    }
    
    startButton.addEventListener('click', () => {
      log('Start button clicked');
      
      // If we're not in AR mode or the board is already placed, start the game
      if (fallbackMode || boardPlaced) {
        startGame();
      } else {
        // Set up for non-AR mode
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        fallbackMode = true;
        startGame();
      }
    });
    
    pauseButton.addEventListener('click', () => {
      if (isGameOver) return;
      
      isPaused = !isPaused;
      pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
      log(`Game ${isPaused ? 'paused' : 'resumed'}`);
      
      if (isPaused) {
        clearInterval(gameInterval);
        gameInterval = null;
        setStatus('ready', 'GAME PAUSED');
      } else {
        gameInterval = setInterval(dropPiece, dropSpeed);
        setStatus('ready', 'GAME RESUMED');
      }
      
      updateStateInfo();
    });
    
    restartButton.addEventListener('click', () => {
      log('Restart button clicked');
      startGame();
    });

    function gameOver() {
      log('Game over');
      isGameOver = true;
      clearInterval(gameInterval);
      gameInterval = null;
      
      setStatus('ready', 'GAME OVER');
      
      // Create game over message in AR space
      const gameOverText = document.createElement('div');
      gameOverText.style.position = 'absolute';
      gameOverText.style.top = '50%';
      gameOverText.style.left = '50%';
      gameOverText.style.transform = 'translate(-50%, -50%)';
      gameOverText.style.color = 'white';
      gameOverText.style.background = 'rgba(0,0,0,0.7)';
      gameOverText.style.padding = '20px';
      gameOverText.style.borderRadius = '10px';
      gameOverText.style.fontSize = '24px';
      gameOverText.style.textAlign = 'center';
      gameOverText.style.zIndex = '1000';
      gameOverText.innerHTML = `Game Over!<br>Final Score: ${score}<br><br>Tap Restart to play again`;
      document.body.appendChild(gameOverText);
      
      setTimeout(() => {
        document.body.removeChild(gameOverText);
      }, 5000);
      
      updateStateInfo();
    }

    // For handling window resize
    window.addEventListener('resize', () => {
      if (!renderer) return;
      
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      log(`Window resized: ${window.innerWidth}x${window.innerHeight}`);
    });

    // Initial camera position for non-AR mode
    camera.position.set(0, 1, 2);
    controls.update();

    // --- AR render loop ---
    function animate(timestamp, frame) {
      if (frame) {
        const session = renderer.xr.getSession();
        
        if (hitTestSource && !boardPlaced) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const hitPose = hit.getPose(localSpace);
            
            reticle.visible = true;
            reticle.matrix.fromArray(hitPose.transform.matrix);
            
            // Add a slight pulsing effect to the reticle
            const pulseScale = 1 + 0.1 * Math.sin(Date.now() * 0.005);
            const scaleMatrix = new THREE.Matrix4().makeScale(pulseScale, pulseScale, pulseScale);
            reticle.matrix.multiply(scaleMatrix);
          } else {
            reticle.visible = false;
          }
        } else if (reticle) {
          reticle.visible = false;
        }
        
        // Handle controller input (if available)
        session.inputSources.forEach(inputSource => {
          if (inputSource.gamepad) {
            const gamepad = inputSource.gamepad;
            
            // Check thumbstick/joystick for movement
            if (gamepad.axes && gamepad.axes.length >= 2) {
              const x = gamepad.axes[0];
              const y = gamepad.axes[1];
              
              // Only respond to significant movement and throttle to avoid too rapid movement
              if (Math.abs(x) > 0.5 && Date.now() % 200 < 100) {
                if (x > 0.5 && !isPaused) {
                  movePiece(1, 0);
                } else if (x < -0.5 && !isPaused) {
                  movePiece(-1, 0);
                }
              }
              
              if (y > 0.5 && !isPaused && Date.now() % 200 < 100) {
                movePiece(0, 1);
              }
            }
          }
        });
      } else {
        // Update OrbitControls in non-XR mode
        if (controls && controls.enabled) {
          controls.update();
        }
      }
      
      if (renderer) {
        renderer.render(scene, camera);
      }
    }
    
    // Start animation loop
    if (renderer) {
      renderer.setAnimationLoop(animate);
      log('Animation loop started');
    }
    
    // Initialize in non-AR fallback mode if needed
    if (fallbackMode && boardGroup && !boardGroup.userData.placed) {
      log('Setting up initial fallback mode');
      boardGroup.position.set(0, 0, -1);
      boardGroup.userData.placed = true;
      boardPlaced = true;
      updateScene();
    }
    
    // Initial state update
    updateStateInfo();
    
    // Log startup complete
    log('Initialization complete - game ready');
    
    // If we detect we're on Oculus Quest specifically
    if (navigator.userAgent.includes('Quest')) {
      log('Oculus Quest device detected');
      
      // Automatically request permission after a short delay
      setTimeout(() => {
        checkPermissionsBtn.click();
      }, 2000);
    }
  </script>
</body>
</html>
