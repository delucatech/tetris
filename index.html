<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Tetris on Oculus Quest 3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
    /* ... [styles remain unchanged] ... */
  </style>
</head>
<body>
  <!-- Status indicator, quick start panel, permission dialog, HUD, debug panel remain unchanged -->
  
  <!-- Three.js and AR code -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // Debug utilities and initial logging remain unchanged
    const debugLog = document.getElementById('debug-log');
    const stateInfo = document.getElementById('state-info');
    const toggleDebugBtn = document.getElementById('toggle-debug');
    const clearLogBtn = document.getElementById('clear-log');
    const checkPermissionsBtn = document.getElementById('check-permissions');
    const checkXRBtn = document.getElementById('check-xr');
    const fallbackModeBtn = document.getElementById('fallback-mode');
    const debugPlaceBoardBtn = document.getElementById('debug-place-board');
    const debugStartGameBtn = document.getElementById('debug-start-game');
    const debugPanel = document.getElementById('debug-panel');
    const statusIndicator = document.getElementById('status-indicator');
    const permissionRequest = document.getElementById('permission-request');
    const xrPermissionBtn = document.getElementById('xr-permission-btn');
    const quickStartPanel = document.getElementById('quick-start');
    const skipARBtn = document.getElementById('skip-ar-btn');
    
    let logMessages = [];
    const MAX_LOG_MESSAGES = 30;
    
    let initStage = 'starting';
    let startButtonClicked = false;
    let xrPermissionGranted = false;
    let fallbackMode = false;
    
    function setStatus(status, message) {
      statusIndicator.className = `status-${status}`;
      statusIndicator.textContent = message;
      log(`STATUS CHANGE: ${message}`);
    }
    
    function log(message) {
      console.log(message);
      const timestamp = new Date().toLocaleTimeString();
      logMessages.push(`[${timestamp}] ${message}`);
      if (logMessages.length > MAX_LOG_MESSAGES) {
        logMessages.shift();
      }
      debugLog.textContent = logMessages.join('\n');
      debugLog.scrollTop = debugLog.scrollHeight;
    }
    
    function updateStateInfo() {
      let stateText = `INIT STAGE: ${initStage}\n`;
      stateText += `Start Button Clicked: ${startButtonClicked ? 'YES' : 'NO'}\n`;
      stateText += `XR Available: ${navigator.xr ? 'YES' : 'NO'}\n`;
      stateText += `XR Permission: ${xrPermissionGranted ? 'GRANTED' : 'UNKNOWN'}\n`;
      stateText += `XR Session Active: ${(renderer && renderer.xr && renderer.xr.isPresenting) ? 'YES' : 'NO'}\n`;
      stateText += `Fallback Mode: ${fallbackMode ? 'YES' : 'NO'}\n`;
      stateText += `Board Placed: ${boardPlaced ? 'YES' : 'NO'}\n`;
      stateText += `Game State: ${isGameOver ? 'Game Over' : isPaused ? 'Paused' : gameInterval ? 'Running' : 'Stopped'}\n`;
      stateText += `Current Piece: ${currentPiece ? 'YES' : 'NO'}\n`;
      stateText += `Renderer: ${renderer ? 'Created' : 'Not Created'}\n`;
      stateText += `Hit Test Source: ${hitTestSource ? 'Available' : 'Not Available'}\n`;
      stateText += `Board Group Position: ${boardGroup ? `(${boardGroup.position.x.toFixed(2)}, ${boardGroup.position.y.toFixed(2)}, ${boardGroup.position.z.toFixed(2)})` : 'N/A'}\n`;
      
      stateInfo.textContent = stateText;
    }
    
    // Debug panel controls remain unchanged...
    
    checkPermissionsBtn.addEventListener('click', () => {
      log('Checking device permissions...');
      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then(supported => {
            log(`AR Session Support: ${supported ? 'YES' : 'NO'}`);
            if (supported) {
              log('Attempting to request temporary XR session to check permissions...');
              navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
              }).then(session => {
                log('SUCCESS: XR session created temporarily - permissions granted');
                xrPermissionGranted = true;
                updateStateInfo();
                session.end();
              }).catch(err => {
                log(`PERMISSION ERROR: ${err.message}`);
                permissionRequest.style.display = 'block';
              });
            }
          });
      } else {
        log('ERROR: WebXR API not available on this device/browser');
      }
      
      if (navigator.permissions) {
        navigator.permissions.query({ name: 'camera' })
          .then(permissionStatus => {
            log(`Camera Permission: ${permissionStatus.state.toUpperCase()}`);
          })
          .catch(err => {
            log(`ERROR checking camera permission: ${err.message}`);
          });
      }
      
      updateStateInfo();
    });
    
    checkXRBtn.addEventListener('click', () => {
      log('Checking WebXR status...');
      if (!navigator.xr) {
        log('ERROR: WebXR API not available in this browser/device');
        return;
      }
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        log(`AR Session Support: ${supported ? 'YES' : 'NO'}`);
      });
      log(`Window Dimensions: ${window.innerWidth}x${window.innerHeight}`);
      log(`Device Pixel Ratio: ${window.devicePixelRatio}`);
      if (renderer) {
        log(`XR Session Active: ${renderer.xr.isPresenting ? 'YES' : 'NO'}`);
        log(`Canvas Size: ${renderer.domElement.width}x${renderer.domElement.height}`);
      } else {
        log('ERROR: Renderer not initialized');
      }
      log(`User Agent: ${navigator.userAgent}`);
      updateStateInfo();
    });
    
    fallbackModeBtn.addEventListener('click', () => {
      log('Entering fallback (non-AR) mode...');
      fallbackMode = true;
      if (renderer && camera) {
        camera.position.set(0, 0.5, 2);
        if (controls) {
          controls.target.set(0, 0, -1);
          controls.update();
        }
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        setStatus('ready', 'FALLBACK MODE');
        log('Board positioned for fallback mode');
        updateScene();
        startGame();
      } else {
        log('ERROR: Cannot enter fallback mode, renderer not initialized');
      }
      updateStateInfo();
    });
    
    debugPlaceBoardBtn.addEventListener('click', () => {
      log('Manually placing board...');
      if (boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        log('Board manually placed at position (0, 0, -1)');
        updateScene();
      } else {
        log('ERROR: Board group not initialized');
      }
      updateStateInfo();
    });
    
    debugStartGameBtn.addEventListener('click', () => {
      log('Forcing game start...');
      startButtonClicked = true;
      if (!boardPlaced && boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
      }
      startGame();
      updateStateInfo();
    });
    
    // Permission request button remains unchanged
    xrPermissionBtn.addEventListener('click', () => {
      log('User clicked XR permission button');
      permissionRequest.style.display = 'none';
      if (navigator.xr) {
        navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        }).then(session => {
          log('XR permission granted!');
          xrPermissionGranted = true;
          session.end();
          if (document.querySelector('.webxr-button')) {
            document.querySelector('.webxr-button').click();
          } else {
            addARButton();
          }
        }).catch(err => {
          log(`ERROR: Failed to get XR permission: ${err.message}`);
          setStatus('error', 'AR UNAVAILABLE');
        });
      }
    });

    // --- Game configuration and state remain unchanged ---
    log('Initializing game configuration...');
    initStage = 'game_config';
    updateStateInfo();
    
    const cellSize = 0.05;
    const COLS = 10, ROWS = 20;
    const boardHeight = ROWS * cellSize;
    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let currentPiece = null;
    let nextPiece = null;
    let gameInterval = null;
    let isPaused = false;
    let isGameOver = false;
    let score = 0;
    let level = 1;
    let lines = 0;
    let dropSpeed = 1000;
    let ghostEnabled = true;
    let boardPlaced = false;
    
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const linesElement = document.getElementById('lines');
    const startButton = document.getElementById('start-btn');
    const pauseButton = document.getElementById('pause-btn');
    const restartButton = document.getElementById('restart-btn');
    const ghostToggle = document.getElementById('ghost-toggle');
    
    const moveLeftBtn = document.getElementById('move-left');
    const moveRightBtn = document.getElementById('move-right');
    const moveDownBtn = document.getElementById('move-down');
    const rotateBtn = document.getElementById('rotate');
    const hardDropBtn = document.getElementById('hard-drop');
    
    ghostToggle.addEventListener('change', () => {
      ghostEnabled = ghostToggle.checked;
      renderGhostPiece3D();
    });
    
    // Tetromino themes and shapes remain unchanged
    const THEMES = {
      classic: {
        I: 0x00FFFF,
        J: 0x0000FF,
        L: 0xFFA500,
        O: 0xFFFF00,
        S: 0x00FF00,
        T: 0x800080,
        Z: 0xFF0000
      }
    };
    const currentTheme = 'classic';
    
    const TETROMINOS = {
      I: { shape: [
          [0,0,0,0],
          [1,1,1,1],
          [0,0,0,0],
          [0,0,0,0]
        ] },
      J: { shape: [
          [1,0,0],
          [1,1,1],
          [0,0,0]
        ] },
      L: { shape: [
          [0,0,1],
          [1,1,1],
          [0,0,0]
        ] },
      O: { shape: [
          [1,1],
          [1,1]
        ] },
      S: { shape: [
          [0,1,1],
          [1,1,0],
          [0,0,0]
        ] },
      T: { shape: [
          [0,1,0],
          [1,1,1],
          [0,0,0]
        ] },
      Z: { shape: [
          [1,1,0],
          [0,1,1],
          [0,0,0]
        ] }
    };
    
    function getShapesWithThemeColors() {
      const shapes = {};
      const themeColors = THEMES[currentTheme];
      for (const key in TETROMINOS) {
        shapes[key] = {
          shape: TETROMINOS[key].shape,
          color: themeColors[key]
        };
      }
      return shapes;
    }
    let SHAPES = getShapesWithThemeColors();
    
    log('Game configuration initialized');
    
    // --- Game logic functions remain unchanged ---
    function getRandomPiece() {
      try {
        const keys = Object.keys(SHAPES);
        const type = keys[Math.floor(Math.random() * keys.length)];
        const tetromino = JSON.parse(JSON.stringify(SHAPES[type]));
        const pieceWidth = tetromino.shape[0].length;
        tetromino.position = { x: Math.floor((COLS - pieceWidth) / 2), y: 0 };
        return tetromino;
      } catch (error) {
        log(`ERROR generating piece: ${error.message}`);
        return {
          shape: [[1,1], [1,1]],
          color: 0xFFFF00,
          position: { x: 4, y: 0 }
        };
      }
    }
    
    function isValidMove(piece, offsetX = 0, offsetY = 0) {
      if (!piece || !piece.shape) {
        log('ERROR: Invalid piece in isValidMove');
        return false;
      }
      const { shape, position } = piece;
      for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
          if (shape[row][col]) {
            const boardRow = position.y + row + offsetY;
            const boardCol = position.x + col + offsetX;
            if (boardCol < 0 || boardCol >= COLS || boardRow >= ROWS) return false;
            if (boardRow >= 0 && board[boardRow][boardCol]) return false;
          }
        }
      }
      return true;
    }
    
    function movePiece(offsetX, offsetY) {
      if (!currentPiece || isPaused || isGameOver) {
        log(`Move failed - Game state: ${isGameOver ? 'Game Over' : isPaused ? 'Paused' : !currentPiece ? 'No current piece' : 'Unknown'}`);
        return false;
      }
      if (isValidMove(currentPiece, offsetX, offsetY)) {
        currentPiece.position.x += offsetX;
        currentPiece.position.y += offsetY;
        updateScene();
        return true;
      }
      return false;
    }
    
    function rotatePiece() {
      if (!currentPiece || isPaused || isGameOver) return;
      const rotatedShape = [];
      for (let col = 0; col < currentPiece.shape[0].length; col++) {
        const newRow = [];
        for (let row = currentPiece.shape.length - 1; row >= 0; row--) {
          newRow.push(currentPiece.shape[row][col]);
        }
        rotatedShape.push(newRow);
      }
      const originalShape = currentPiece.shape;
      const originalPosition = { ...currentPiece.position };
      currentPiece.shape = rotatedShape;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      currentPiece.position.x += 1;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      currentPiece.position.x = originalPosition.x - 1;
      if (isValidMove(currentPiece)) {
        updateScene();
        return;
      }
      currentPiece.shape = originalShape;
      currentPiece.position = originalPosition;
    }
    
    function hardDrop() {
      if (!currentPiece || isPaused || isGameOver) return;
      let dropDistance = 0;
      while (isValidMove(currentPiece, 0, dropDistance + 1)) {
        dropDistance++;
      }
      if (dropDistance > 0) {
        currentPiece.position.y += dropDistance;
        updateScene();
        lockPiece();
      }
    }
    
    function lockPiece() {
      log('Locking piece into board');
      if (!currentPiece) {
        log('ERROR: No current piece to lock');
        return;
      }
      const { shape, position, color } = currentPiece;
      shape.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
          if (value) {
            const boardRow = position.y + rowIndex;
            const boardCol = position.x + colIndex;
            if (boardRow >= 0 && boardRow < ROWS && boardCol >= 0 && boardCol < COLS) {
              board[boardRow][boardCol] = color;
            }
          }
        });
      });
      checkLines();
      currentPiece = nextPiece;
      nextPiece = getRandomPiece();
      updateScene();
      if (!isValidMove(currentPiece)) gameOver();
    }
    
    function checkLines() {
      let linesCleared = 0;
      for (let row = ROWS - 1; row >= 0; row--) {
        if (board[row].every(cell => cell !== 0)) {
          board.splice(row, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          row++;
        }
      }
      if (linesCleared > 0) {
        const pointValues = [0, 100, 300, 500, 800];
        score += pointValues[linesCleared] * level;
        lines += linesCleared;
        level = Math.floor(lines / 10) + 1;
        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
        
        log(`Cleared ${linesCleared} lines! Score: ${score}, Level: ${level}`);
        
        if (gameInterval) {
          clearInterval(gameInterval);
          gameInterval = setInterval(dropPiece, dropSpeed);
        }
      }
    }
    
    function dropPiece() {
      if (!currentPiece || isPaused || isGameOver) return;
      if (!movePiece(0, 1)) lockPiece();
    }
    
    function getGhostPosition() {
      if (!currentPiece) return null;
      let ghost = JSON.parse(JSON.stringify(currentPiece));
      while (isValidMove(ghost, 0, 1)) {
        ghost.position.y += 1;
      }
      return ghost.position;
    }
    
    // --- Three.js AR scene setup ---
    log('Initializing Three.js...');
    initStage = 'three_setup';
    updateStateInfo();
    setStatus('initializing', 'SETTING UP THREE.JS');
    
    let scene, camera, renderer, controls;
    let hitTestSource = null;
    let localSpace = null;
    let reticle = null;
    let boardGroup, activePieceGroup, ghostGroup;
    
    try {
      scene = new THREE.Scene();
      log('Scene created');
      
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      log('Camera created');
      
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        preserveDrawingBuffer: true
      });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      log(`Renderer created: ${renderer.domElement.width}x${renderer.domElement.height}, Pixel Ratio: ${window.devicePixelRatio}`);
      
      try {
        renderer.xr.enabled = true;
        log('WebXR enabled on renderer');
      } catch (xrError) {
        log(`ERROR enabling XR: ${xrError.message}`);
        setStatus('error', 'XR ERROR');
      }
      
      document.body.appendChild(renderer.domElement);
      log('Renderer added to document');
      
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, -1);
      controls.enableDamping = true;
      controls.enabled = true;
      log('Orbit controls initialized');
      
      camera.position.set(0, 0.5, 2);
      controls.update();
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 2, 3);
      scene.add(directionalLight);
      log('Lighting set up');
      
      boardGroup = new THREE.Group();
      boardGroup.userData.placed = false;
      scene.add(boardGroup);
      log('Board group created');
      
      activePieceGroup = new THREE.Group();
      scene.add(activePieceGroup);
      
      ghostGroup = new THREE.Group();
      scene.add(ghostGroup);
      log('Game element groups created');
      
      const boardOutlineGeometry = new THREE.BoxGeometry(
        COLS * cellSize, ROWS * cellSize, cellSize/10
      );
      boardOutlineGeometry.translate(0, boardHeight/2 - cellSize/2, -cellSize/10);
      
      const boardOutlineMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.5,
        wireframe: true
      });
      
      const boardOutline = new THREE.Mesh(boardOutlineGeometry, boardOutlineMaterial);
      boardGroup.add(boardOutline);
      log('Board outline created');
      
      const groundGeometry = new THREE.PlaneGeometry(COLS * cellSize * 2, COLS * cellSize * 2);
      groundGeometry.rotateX(-Math.PI / 2);
      const groundMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x444444, 
        transparent: true, 
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.position.y = -0.01;
      boardGroup.add(ground);
      log('Ground plane created');
      
      const reticleGeometry = new THREE.RingGeometry(0.05, 0.06, 32);
      reticleGeometry.rotateX(-Math.PI / 2);
      const reticleMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88,
        transparent: true,
        opacity: 0.8
      });
      reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
      log('Reticle created');
      
      log('Three.js setup complete');
      initStage = 'xr_setup';
      updateStateInfo();
      
    } catch (error) {
      log(`CRITICAL ERROR in Three.js setup: ${error.message}`);
      console.error(error);
      setStatus('error', 'SETUP ERROR');
    }
    
    // --- Quick start (non-AR) handling ---
    skipARBtn.addEventListener('click', () => {
      log('User clicked Skip AR button');
      quickStartPanel.style.display = 'none';
      fallbackMode = true;
      setStatus('ready', 'NON-AR MODE');
      if (boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
      }
      setTimeout(() => {
        startGame();
      }, 100);
    });
    
    // Remove auto‑trigger for Oculus Quest permission – rely on user interaction instead.
    // if (navigator.userAgent.includes('Quest')) {
    //   log('Oculus Quest device detected');
    //   setTimeout(() => {
    //     checkPermissionsBtn.click();
    //   }, 2000);
    // }
    
    log('Checking WebXR support...');
    try {
      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then(supported => {
            log(`WebXR AR Support: ${supported ? 'YES' : 'NO'}`);
            setTimeout(() => {
              quickStartPanel.style.display = 'none';
            }, 2000);
            if (supported) {
              log('Adding AR button...');
              addARButton();
              setStatus('initializing', 'READY - TAP AR BUTTON');
            } else {
              log('AR not supported, entering fallback mode');
              fallbackMode = true;
              setStatus('ready', 'FALLBACK MODE');
              boardGroup.position.set(0, 0, -1);
              boardGroup.userData.placed = true;
              boardPlaced = true;
              updateScene();
            }
            initStage = 'ready';
            updateStateInfo();
          })
          .catch(err => {
            log(`ERROR checking AR support: ${err.message}`);
            fallbackMode = true;
            setStatus('error', 'XR ERROR - FALLBACK MODE');
            boardGroup.position.set(0, 0, -1);
            boardGroup.userData.placed = true;
            boardPlaced = true;
          });
      } else {
        log('WebXR API not available, entering fallback mode');
        fallbackMode = true;
        setStatus('ready', 'FALLBACK MODE');
        setTimeout(() => {
          quickStartPanel.style.display = 'none';
        }, 2000);
        if (boardGroup) {
          boardGroup.position.set(0, 0, -1);
          boardGroup.userData.placed = true;
          boardPlaced = true;
          updateScene();
        }
      }
    } catch (error) {
      log(`CRITICAL ERROR checking WebXR: ${error.message}`);
      fallbackMode = true;
      setStatus('error', 'CRITICAL ERROR - FALLBACK MODE');
      if (boardGroup) {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        updateScene();
      }
    }
    
    function addARButton() {
      try {
        const arButton = ARButton.createButton(renderer, { 
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay', 'hand-tracking'],
          domOverlay: { root: document.body },
          sessionInit: {
            environmentIntegration: true
          }
        });
        arButton.style.padding = '12px 24px';
        arButton.style.fontSize = '16px';
        arButton.style.fontWeight = 'bold';
        arButton.style.backgroundColor = '#4285F4';
        document.body.appendChild(arButton);
        log('AR Button added to document');
        startButton.textContent = 'Start Game (Non-AR)';
      } catch (err) {
        log(`ERROR adding AR button: ${err.message}`);
        setStatus('error', 'AR BUTTON ERROR');
      }
    }
    
    if (renderer) {
      renderer.xr.addEventListener('sessionstart', async () => {
        log('XR Session Started!');
        setStatus('initializing', 'AR SESSION ACTIVE');
        const session = renderer.xr.getSession();
        try {
          const viewerSpace = await session.requestReferenceSpace('viewer');
          hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
          localSpace = await session.requestReferenceSpace('local');
          log('Hit testing initialized successfully');
          controls.enabled = false;
          session.addEventListener('select', onSelect);
          log('XR select event listener added');
          setStatus('ready', 'POINT AND TAP TO PLACE');
        } catch (error) {
          log(`ERROR during XR session setup: ${error.message}`);
          setStatus('error', 'AR SESSION ERROR');
        }
        updateStateInfo();
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        log('XR Session Ended');
        setStatus('ready', 'AR SESSION ENDED');
        hitTestSource = null;
        localSpace = null;
        controls.enabled = true;
        if (!gameInterval) {
          boardPlaced = false;
          boardGroup.userData.placed = false;
        }
        updateStateInfo();
      });
    }
    
    function onSelect() {
      log('XR Select Event Triggered');
      if (reticle.visible && !boardPlaced) {
        log('Placing board at hit test position');
        try {
          const matrix = new THREE.Matrix4();
          matrix.fromArray(reticle.matrix.elements);
          const position = new THREE.Vector3();
          position.setFromMatrixPosition(matrix);
          boardGroup.position.copy(position);
          boardGroup.position.y += boardHeight / 2;
          boardGroup.userData.placed = true;
          boardPlaced = true;
          log(`Board placed at position: (${boardGroup.position.x.toFixed(2)}, ${boardGroup.position.y.toFixed(2)}, ${boardGroup.position.z.toFixed(2)})`);
          setStatus('ready', 'BOARD PLACED');
          startGame();
        } catch (error) {
          log(`ERROR placing board: ${error.message}`);
        }
      } else {
        log(`Board placement skipped: reticle visible: ${reticle ? reticle.visible : 'no reticle'}, board already placed: ${boardPlaced}`);
      }
      updateStateInfo();
    }
    
    function boardToWorld(row, col) {
      const x = (col - COLS/2) * cellSize + cellSize/2;
      const y = boardHeight - row*cellSize - cellSize;
      const z = 0;
      return new THREE.Vector3(x, y, z);
    }
    
    // --- 3D Rendering functions remain unchanged ---
    let instancedMeshes = {};
    function createInstancedMesh(color) {
      const colorKey = color.toString();
      if (!instancedMeshes[colorKey]) {
        const geometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, cellSize * 0.9);
        const material = new THREE.MeshStandardMaterial({ 
          color: color,
          roughness: 0.7,
          metalness: 0.2
        });
        instancedMeshes[colorKey] = { geometry, material };
      }
      return instancedMeshes[colorKey];
    }
    
    function renderBoard3D() {
      try {
        const childrenBefore = boardGroup ? boardGroup.children.length : 0;
        if (boardGroup) {
          while(boardGroup.children.length > 2) {
            boardGroup.remove(boardGroup.children[2]);
          }
          const colorGroups = {};
          for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
              const colorValue = board[row][col];
              if (colorValue) {
                if (!colorGroups[colorValue]) {
                  colorGroups[colorValue] = [];
                }
                colorGroups[colorValue].push({ row, col });
              }
            }
          }
          for (const colorValue in colorGroups) {
            const cells = colorGroups[colorValue];
            const { geometry, material } = createInstancedMesh(colorValue);
            for (const cell of cells) {
              const pos = boardToWorld(cell.row, cell.col);
              const cube = new THREE.Mesh(geometry, material);
              cube.position.copy(pos);
              boardGroup.add(cube);
            }
          }
          const childrenAfter = boardGroup.children.length;
          if (childrenAfter > childrenBefore) {
            log(`Board rendered: ${childrenAfter - 2} blocks`);
          }
        } else {
          log('ERROR: boardGroup is undefined in renderBoard3D');
        }
      } catch (error) {
        log(`ERROR rendering board: ${error.message}`);
      }
    }
    
    function renderActivePiece3D() {
      try {
        if (activePieceGroup) {
          while(activePieceGroup.children.length) {
            activePieceGroup.remove(activePieceGroup.children[0]);
          }
          if (!currentPiece) return;
          const { shape, position, color } = currentPiece;
          const { geometry, material } = createInstancedMesh(color);
          if (boardGroup) {
            activePieceGroup.position.copy(boardGroup.position);
          }
          let blocksAdded = 0;
          shape.forEach((rowArr, rowIndex) => {
            rowArr.forEach((value, colIndex) => {
              if (value) {
                const boardRow = position.y + rowIndex;
                const boardCol = position.x + colIndex;
                const pos = boardToWorld(boardRow, boardCol);
                const cube = new THREE.Mesh(geometry, material);
                cube.position.copy(pos);
                activePieceGroup.add(cube);
                blocksAdded++;
              }
            });
          });
        } else {
          log('ERROR: activePieceGroup is undefined in renderActivePiece3D');
        }
      } catch (error) {
        log(`ERROR rendering active piece: ${error.message}`);
      }
    }
    
    function renderGhostPiece3D() {
      try {
        if (ghostGroup) {
          while(ghostGroup.children.length) {
            ghostGroup.remove(ghostGroup.children[0]);
          }
          if (!currentPiece || !ghostEnabled) return;
          const ghostPos = getGhostPosition();
          const { shape, color } = currentPiece;
          const geometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, cellSize * 0.9);
          const material = new THREE.MeshStandardMaterial({ 
            color: color, 
            transparent: true, 
            opacity: 0.3,
            wireframe: false
          });
          if (boardGroup) {
            ghostGroup.position.copy(boardGroup.position);
          }
          shape.forEach((rowArr, rowIndex) => {
            rowArr.forEach((value, colIndex) => {
              if (value) {
                const boardRow = ghostPos.y + rowIndex;
                const boardCol = ghostPos.x + colIndex;
                const pos = boardToWorld(boardRow, boardCol);
                const cube = new THREE.Mesh(geometry, material);
                cube.position.copy(pos);
                ghostGroup.add(cube);
              }
            });
          });
        } else {
          log('ERROR: ghostGroup is undefined in renderGhostPiece3D');
        }
      } catch (error) {
        log(`ERROR rendering ghost piece: ${error.message}`);
      }
    }
    
    function updateScene() {
      renderBoard3D();
      renderActivePiece3D();
      renderGhostPiece3D();
    }
    
    // --- User input handling remains unchanged ---
    function handleKeydown(event) {
      if (isPaused || isGameOver) return;
      switch(event.key) {
        case 'ArrowLeft': movePiece(-1, 0); break;
        case 'ArrowRight': movePiece(1, 0); break;
        case 'ArrowDown': movePiece(0, 1); break;
        case 'ArrowUp': rotatePiece(); break;
        case ' ': case 'Spacebar': hardDrop(); break;
      }
    }
    document.addEventListener('keydown', handleKeydown);
    
    moveLeftBtn.addEventListener('click', () => { log('Left button pressed'); movePiece(-1, 0); });
    moveRightBtn.addEventListener('click', () => { log('Right button pressed'); movePiece(1, 0); });
    moveDownBtn.addEventListener('click', () => { log('Down button pressed'); movePiece(0, 1); });
    rotateBtn.addEventListener('click', () => { log('Rotate button pressed'); rotatePiece(); });
    hardDropBtn.addEventListener('click', () => { log('Hard drop button pressed'); hardDrop(); });
    
    // --- Game control functions ---
    function startGame() {
      try {
        log('Starting game...');
        startButtonClicked = true;
        if (gameInterval) {
          log('Clearing existing game interval');
          clearInterval(gameInterval);
        }
        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        score = 0;
        level = 1;
        lines = 0;
        dropSpeed = 1000;
        isPaused = false;
        isGameOver = false;
        
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
        
        if (quickStartPanel) {
          quickStartPanel.style.display = 'none';
        }
        
        log('Creating pieces');
        currentPiece = getRandomPiece();
        nextPiece = getRandomPiece();
        
        if ((!renderer.xr.isPresenting || fallbackMode) && 
            (!boardGroup.userData.placed || !boardPlaced)) {
          log('Setting up board for non-AR mode');
          camera.position.set(0, 1, 2);
          if (controls) controls.update();
          boardGroup.position.set(0, 0, -1);
          boardGroup.userData.placed = true;
          boardPlaced = true;
        }
        
        log('Updating scene');
        updateScene();
        
        const testCube = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.1, 0.1),
          new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        testCube.position.set(0, 0, -1);
        scene.add(testCube);
        log('Added test cube for visibility check');
        
        log('Starting game interval');
        gameInterval = setInterval(dropPiece, dropSpeed);
        
        const startMessage = document.createElement('div');
        startMessage.style.position = 'absolute';
        startMessage.style.top = '50%';
        startMessage.style.left = '50%';
        startMessage.style.transform = 'translate(-50%, -50%)';
        startMessage.style.background = 'rgba(0,0,0,0.7)';
        startMessage.style.color = 'white';
        startMessage.style.padding = '20px';
        startMessage.style.borderRadius = '10px';
        startMessage.style.fontSize = '24px';
        startMessage.style.zIndex = '1000';
        startMessage.innerHTML = 'Game Started!';
        document.body.appendChild(startMessage);
        
        setTimeout(() => {
          document.body.removeChild(startMessage);
        }, 2000);
        
        log('Game started successfully');
        setStatus('ready', 'GAME STARTED');
        updateStateInfo();
      } catch (error) {
        log(`ERROR starting game: ${error.message}`);
        console.error(error);
        setStatus('error', 'START ERROR');
        alert(`Error starting game: ${error.message}. Check debug panel for details.`);
      }
    }
    
    startButton.addEventListener('click', () => {
      log('Start button clicked');
      if (fallbackMode || boardPlaced) {
        startGame();
      } else {
        boardGroup.position.set(0, 0, -1);
        boardGroup.userData.placed = true;
        boardPlaced = true;
        fallbackMode = true;
        startGame();
      }
    });
    
    pauseButton.addEventListener('click', () => {
      if (isGameOver) return;
      isPaused = !isPaused;
      pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
      log(`Game ${isPaused ? 'paused' : 'resumed'}`);
      if (isPaused) {
        clearInterval(gameInterval);
        gameInterval = null;
        setStatus('ready', 'GAME PAUSED');
      } else {
        gameInterval = setInterval(dropPiece, dropSpeed);
        setStatus('ready', 'GAME RESUMED');
      }
      updateStateInfo();
    });
    
    restartButton.addEventListener('click', () => {
      log('Restart button clicked');
      startGame();
    });
    
    function gameOver() {
      log('Game over');
      isGameOver = true;
      clearInterval(gameInterval);
      gameInterval = null;
      setStatus('ready', 'GAME OVER');
      const gameOverText = document.createElement('div');
      gameOverText.style.position = 'absolute';
      gameOverText.style.top = '50%';
      gameOverText.style.left = '50%';
      gameOverText.style.transform = 'translate(-50%, -50%)';
      gameOverText.style.color = 'white';
      gameOverText.style.background = 'rgba(0,0,0,0.7)';
      gameOverText.style.padding = '20px';
      gameOverText.style.borderRadius = '10px';
      gameOverText.style.fontSize = '24px';
      gameOverText.style.textAlign = 'center';
      gameOverText.style.zIndex = '1000';
      gameOverText.innerHTML = `Game Over!<br>Final Score: ${score}<br><br>Tap Restart to play again`;
      document.body.appendChild(gameOverText);
      setTimeout(() => {
        document.body.removeChild(gameOverText);
      }, 5000);
      updateStateInfo();
    }
    
    window.addEventListener('resize', () => {
      if (!renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      log(`Window resized: ${window.innerWidth}x${window.innerHeight}`);
    });
    
    camera.position.set(0, 1, 2);
    controls.update();
    
    function animate(timestamp, frame) {
      if (frame) {
        const session = renderer.xr.getSession();
        if (hitTestSource && !boardPlaced) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const hitPose = hit.getPose(localSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(hitPose.transform.matrix);
            const pulseScale = 1 + 0.1 * Math.sin(Date.now() * 0.005);
            const scaleMatrix = new THREE.Matrix4().makeScale(pulseScale, pulseScale, pulseScale);
            reticle.matrix.multiply(scaleMatrix);
          } else {
            reticle.visible = false;
          }
        } else if (reticle) {
          reticle.visible = false;
        }
        
        session.inputSources.forEach(inputSource => {
          if (inputSource.gamepad) {
            const gamepad = inputSource.gamepad;
            if (gamepad.axes && gamepad.axes.length >= 2) {
              const x = gamepad.axes[0];
              const y = gamepad.axes[1];
              if (Math.abs(x) > 0.5 && Date.now() % 200 < 100) {
                if (x > 0.5 && !isPaused) {
                  movePiece(1, 0);
                } else if (x < -0.5 && !isPaused) {
                  movePiece(-1, 0);
                }
              }
              if (y > 0.5 && !isPaused && Date.now() % 200 < 100) {
                movePiece(0, 1);
              }
            }
          }
        });
      } else {
        if (controls && controls.enabled) {
          controls.update();
        }
      }
      if (renderer) {
        renderer.render(scene, camera);
      }
    }
    
    if (renderer) {
      renderer.setAnimationLoop(animate);
      log('Animation loop started');
    }
    
    if (fallbackMode && boardGroup && !boardGroup.userData.placed) {
      log('Setting up initial fallback mode');
      boardGroup.position.set(0, 0, -1);
      boardGroup.userData.placed = true;
      boardPlaced = true;
      updateScene();
    }
    
    updateStateInfo();
    log('Initialization complete - game ready');
  </script>
</body>
</html>
